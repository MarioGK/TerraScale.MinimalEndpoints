using TerraScale.MinimalEndpoints.Analyzers.Helpers;
using TerraScale.MinimalEndpoints.Analyzers.Models;

namespace TerraScale.MinimalEndpoints.Analyzers.Generators;

internal static class EndpointRegistrationGenerator
{
    public static string GenerateEndpointRegistrationCode(List<EndpointMethod> endpointMethods, string assemblyName)
    {
        var sb = new IndentedStringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using Microsoft.AspNetCore.Routing;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.AspNetCore.Http;");

        sb.AppendLine();
        // Use a unique namespace per assembly to avoid ambiguous extension method
        // conflicts when multiple assemblies generate registration helpers. Sanitize
        // assemblyName into a simple identifier.
        var sanitized = new string(assemblyName.Select(c => char.IsLetterOrDigit(c) ? c : '_').ToArray());
        sb.AppendLine($"namespace TerraScale.MinimalEndpoints.Generated_{sanitized};");
        sb.AppendLine();
        sb.AppendLine("public static class MinimalEndpointRegistration");
        sb.AppendLine("{");

        using (sb.Indent())
        {
            // AddMinimalEndpoints (generated) - use unique names to avoid conflicts when multiple
            // assemblies produce generated registration code. Consumers should call the generated
            // versions below (AddGeneratedMinimalEndpoints / MapGeneratedMinimalEndpoints).
            sb.AppendLine("public static IServiceCollection AddGeneratedMinimalEndpoints(this IServiceCollection services)");
            sb.AppendLine("{");
            using (sb.Indent())
            {
                var distinctClasses = endpointMethods
                    .Select(m => new { m.ClassNamespace, m.ClassName })
                    .Distinct()
                    .OrderBy(x => x.ClassNamespace).ThenBy(x => x.ClassName);

                foreach (var cls in distinctClasses)
                {
                    var fullName = string.IsNullOrEmpty(cls.ClassNamespace) ? cls.ClassName : $"{cls.ClassNamespace}.{cls.ClassName}";
                    sb.AppendLine("// Suppress 'Class is never used' warning - endpoint classes are used by source generator");
                    sb.AppendLine("#pragma warning disable CS0169");
                    sb.AppendLine($"services.AddScoped<{fullName}>();");
                    sb.AppendLine("#pragma warning restore CS0169");
                }

                sb.AppendLine("return services;");
            }
            sb.AppendLine("}");
            sb.AppendLine();

            // MapMinimalEndpoints (generated)
            sb.AppendLine("public static void MapGeneratedMinimalEndpoints(this IEndpointRouteBuilder endpoints)");
            sb.AppendLine("{");
            using (sb.Indent())
            {
                if (endpointMethods.Count == 0)
                {
                    sb.AppendLine("// No endpoints found to register");
                }
                else
                {
                    foreach (var method in endpointMethods)
                    {
                        GenerateMethodRegistration(sb, method);
                    }
                }
            }
            sb.AppendLine("}");
        }
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateMethodRegistration(IndentedStringBuilder sb, EndpointMethod method)
    {
        sb.AppendLine();
        sb.AppendLine($"// Register {method.ClassName}.{method.MethodName}");
        sb.AppendLine("{");

        using (sb.Indent())
        {
            string routePattern;
            if (string.IsNullOrEmpty(method.Route))
            {
                routePattern = $"/{method.ClassName}/{method.MethodName}";
            }
            else
            {
                routePattern = method.Route.StartsWith("/") ? method.Route : $"/{method.Route}";
            }

            var firstChar = method.HttpMethod.Length > 0 ? method.HttpMethod.Substring(0, 1).ToUpperInvariant() : "";
            var rest = method.HttpMethod.Length > 1 ? method.HttpMethod.Substring(1).ToLowerInvariant() : "";
            var pascalHttpMethod = firstChar + rest;

            // Prepare lambda parameters
            var lambdaParams = new List<string>();

            // Inject the instance itself!
            var instanceType = string.IsNullOrEmpty(method.ClassNamespace) ? method.ClassName : $"{method.ClassNamespace}.{method.ClassName}";
            lambdaParams.Add($"[Microsoft.AspNetCore.Mvc.FromServices] {instanceType} instance");

            // Check for HttpContext parameter in user method
            var httpContextParam = method.Parameters.FirstOrDefault(p => p.Type.EndsWith("HttpContext"));
            var httpContextVarName = httpContextParam?.Name ?? "httpContext";

            foreach (var param in method.Parameters)
            {
                var attributes = new List<string>();
                if (param.IsFromServices) attributes.Add("[Microsoft.AspNetCore.Mvc.FromServices]");
                if (param.IsFromBody) attributes.Add("[Microsoft.AspNetCore.Mvc.FromBody]");
                if (param.IsFromQuery) attributes.Add("[Microsoft.AspNetCore.Mvc.FromQuery]");
                if (param.IsFromRoute) attributes.Add("[Microsoft.AspNetCore.Mvc.FromRoute]");

                var attrString = attributes.Any() ? string.Join(" ", attributes) + " " : "";
                lambdaParams.Add($"{attrString}{param.Type} {param.Name}");
            }

            // If HttpContext is not in parameters, add it to lambda params so we can use it
            if (httpContextParam == null)
            {
                lambdaParams.Add($"HttpContext {httpContextVarName}");
            }

            sb.AppendLine($"var builder = endpoints.Map{pascalHttpMethod}(\"{routePattern}\", async (");
            sb.AppendLine($"    {string.Join(", ", lambdaParams)}) =>");

            sb.AppendLine("{");
            using (sb.Indent())
            {
                // Set Context on base class if applicable
                // Check if instance inherits from BaseMinimalApiEndpoint
                // Use fully qualified name for BaseMinimalApiEndpoint: TerraScale.MinimalEndpoints.BaseMinimalApiEndpoint
                sb.AppendLine($"if (instance is TerraScale.MinimalEndpoints.BaseMinimalApiEndpoint baseEp)");
                sb.AppendLine("{");
                using (sb.Indent())
                {
                    sb.AppendLine($"baseEp.Context = {httpContextVarName};");
                }
                sb.AppendLine("}");

                var methodCallParams = string.Join(", ", method.Parameters.Select(p => p.Name));

                if (method.ReturnType.Contains("Task"))
                {
                    sb.AppendLine($"return await instance.{method.MethodName}({methodCallParams});");
                }
                else
                {
                    sb.AppendLine($"return instance.{method.MethodName}({methodCallParams});");
                }
            }
            sb.AppendLine("});"); // End of Map call

            // Add OpenAPI metadata
            if (!string.IsNullOrEmpty(method.Summary))
            {
                sb.AppendLine($"builder.WithName(\"{EscapeString(method.MethodName)}\");");
                sb.AppendLine($"builder.WithSummary(\"{EscapeString(method.Summary)}\");");
            }

            if (!string.IsNullOrEmpty(method.Description))
            {
                sb.AppendLine($"builder.WithDescription(\"{EscapeString(method.Description)}\");");
            }

            // Add tags
            var allTags = new List<string>();
            if (method.Tags.Any())
            {
                allTags.AddRange(method.Tags);
            }

            if (allTags.Any())
            {
                var tagsArray = string.Join(", ", allTags.Select(t => $"\"{EscapeString(t)}\""));
                sb.AppendLine($"builder.WithTags(new[] {{ {tagsArray} }});");
            }

            // Add group name
            if (!string.IsNullOrEmpty(method.GroupName) && method.GroupName != method.ClassName)
            {
                sb.AppendLine($"builder.WithGroupName(\"{EscapeString(method.GroupName)}\");");
            }

            // Add produces content types
            foreach (var prod in method.Produces)
            {
                 var first = prod.ContentTypes.FirstOrDefault() ?? "application/json";
                 var others = prod.ContentTypes.Skip(1).Select(p => $"\"{EscapeString(p)}\"").ToList();
                 var othersArg = others.Any() ? ", " + string.Join(", ", others) : "";

                 sb.AppendLine($"builder.Produces({prod.StatusCode}, typeof({method.ReturnTypeInner}), \"{EscapeString(first)}\"{othersArg});");
            }

            // Add consumes content types via Accepts
            if (method.Consumes.Any())
            {
                var bodyParam = method.Parameters.FirstOrDefault(p => p.IsFromBody);
                var typeString = bodyParam != null ? $"typeof({bodyParam.Type})" : "typeof(object)";

                var first = method.Consumes[0];
                var others = method.Consumes.Skip(1).Select(c => $"\"{EscapeString(c)}\"").ToList();
                var othersArg = others.Any() ? ", " + string.Join(", ", others) : "";

                sb.AppendLine($"builder.Accepts({typeString}, \"{EscapeString(first)}\"{othersArg});");
            }

            // Add response descriptions
            foreach (var response in method.ResponseDescriptions)
            {
                 var typeToUse = response.Key == 200 ? $"typeof({method.ReturnTypeInner})" : "typeof(void)";
                 sb.AppendLine($"builder.Produces({response.Key}, {typeToUse});");
            }

            if (method.IsDeprecated)
            {
                sb.AppendLine($"builder.WithOpenApi(op => {{ op.Deprecated = true; return op; }});");
            }

            // Add endpoint filters
            foreach (var filter in method.EndpointFilters)
            {
                sb.AppendLine($"builder.AddEndpointFilter<{filter}>();");
            }

            // Call Configure method if exists
            if (method.HasConfigureMethod)
            {
                 var typeName = string.IsNullOrEmpty(method.ClassNamespace) ? method.ClassName : $"{method.ClassNamespace}.{method.ClassName}";
                 sb.AppendLine($"{typeName}.Configure(builder);");
            }
        }
        sb.AppendLine("}");
    }

    private static string EscapeString(string? input)
    {
        if (string.IsNullOrEmpty(input))
            return string.Empty;

        return input!.Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r").Replace("\t", "\\t");
    }
}
